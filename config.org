
#+TITLE: Emacs Configuration File
#+AUTHOR: Vikram Bakshi
#+STARTUP: inlineimages

Key binding explanations:
- C-c <C-left> - Means CTRL must be pressed for both.

LOOK UP AND BIND WINNER MODE
LOOK UP AND ENABLE FLEX IDO MODE:
  - https://github.com/lewang/flx
  - 09 Buffers, Windows and IDO Mode

* Use-package notes
** Use-package

The use-package macro is used to configure packages. The syntax is simple:

(use-package <package-name>
   :<keyword> <arbitrary-elisp>
   :<keyword> <arbitrary-elisp>
   : ...
)

The simplest declaration is: (use-package foo)
Each subsection below describes a keyword and example usage.

*** :init

Executes code before a package is loaded.

Example:
(use-package foo
  :init
  (setq foo-variable t))

*** :config

Executes code after a package is loaded.

*** :bind

*Example:*
(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))

This does two things: first, it creates an autoload for the
ace-jump-mode command and defers loading of ace-jump-mode until you
actually use it. Second, it binds the key C-. to that command.

*Example 2*
(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
Same, but taking a list or a list of conses.

*** :mode
*** :ensure
*** :interpreter
*** :load-path

*Example 1*
(use-package ess-site
  :load-path "site-lisp/ess/lisp/"
  :commands R)

*Description*
This takes a symbol, a function, a string or a list of strings. If
the path is relative, it is expanded within user-emacs-directory:

*** :no-require
*** :if

(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))

*** :diminish

*Example 1*
(use-package abbrev
  :diminish abbrev-mode
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
*Description*
Removes the minor mode string from the modeline.


Use the :init keyword to execute code before a package is loaded. 
It accepts one or more forms, up until the next keyword:

-  In general, you should keep :init forms as simple and quick as
   possible, and put as much as you can get away with into the :config
   block. This way, deferred loading can help your Emacs to start as
   quickly as possible.

* Initialisation

Customisation options included here are placed for a faster/faster
looking initialisation.

#+BEGIN_SRC emacs-lisp

;; Turn off mouse interface early in startup to avoid momentary display
(when window-system
  ;; (menu-bar-mode -1)    ;; Menu bar - file, edit, etc.
  (tool-bar-mode -1)    ;; Tool bar - buttons under menu bar.
  (scroll-bar-mode -1)  ;; Scroll bar on side of buffers
  ;; (tooltip-mode -1)    ;; On: Help text as popup/Off: as text in minibuffer.
)

;; Don't show the tutorial startup page.
(setq inhibit-startup-message t) 

#+END_SRC

* Load Path

The following contains directories which are added to emac's load path.
That way if you want to configure a package which is not installed using MELPA
but exists in another folder - you can.

N.B. The (add-to-list 'load-path <path>) function DOES NOT 
recursively add subdirectories.

#+BEGIN_SRC emacs-lisp

;; "~/.emacs.d/lisp/" for custom downloaded lisp files.
(add-to-list 'load-path "~/.emacs.d/lisp/")  

#+END_SRC

* Personal Minor Mode
Create my own minor mode to contain my own functionality.
See 
- tutsplus - Venture into Emacs/02 Usage/12 Major and Minor Modes
- tutsplus - Venture into Emacs/02 Usage/13 Customizations


  
** Custom Minor Mode Functions
   
* Dired Mode

We can give the options that dired mode uses when it calls ls so that
they are: 

- l: Use the long listing format.
- a: Show all files including hidden ones.
- h: Print sizes in human readable format (K, M G etc.)
- F: Append an indicator onto relevant files/directories:
  - / is a directory
  - @ is a symlink
  - | is a named pipe (fifo)
  - = is a socket.
  - * for executable files
  - > is for a "door" -- a file type currently not implemented for Linux, but supported on Sun/Solaris.

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lahF")
#+END_SRC

* Minibuffer

Set the colour of the minibuffer prompt to green for better readability.
#+BEGIN_SRC emacs-lisp
 (custom-set-faces  
  '(minibuffer-prompt ((t (:foreground "green"))))  
 )  
#+END_SRC
** Powerline

#+begin_src emacs-lisp
(use-package powerline
  :ensure t
  :init (powerline-center-theme)
)
#+end_src

* Buffers, Windows, Frames, and Scratch Buffer
** Buffers
*** ibuffer

iBuffer is an improved version of the default 'C-x C-b' (list-buffers
command). It comes with emacs by default so to use it we just need to define the
list-buffers command as an alias for it.

See: http://ergoemacs.org/emacs/emacs_buffer_management.html

#+begin_src emacs-lisp
;; make ibuffer the default buffer lister.
(defalias 'list-buffers 'ibuffer)
#+end_src

** Windows
*** Existing Bindings

| Keys  | Command              | Description                                            |
| C-x o | other-window         | Move point to other window.                            |
| C-x 0 | delete-window        | Deletes current window, reducing window count by 1.    |
| C-x 1 | delete-other-windows | Makes window point is on, sole window.                 |
| C-x 2 | split-window-below   | Splits current window horizontally into two.           |
| C-x 3 | split-window-right   | Splits current window vertically into two.             |
| C-x 4 |                      |                                                        |
| C-x 5 |                      | Used as a prefix for frame commands                    |
| C-x + | balance-windows      | Undos the affects of resizing windows so they balance. |
|       |                      |                                                        |


*** Custom Bindings
**** Splitting windows

Splitting windows does not move the cursor to the other window. The following
remaps the default keys to move to the other window when it is created.

#+begin_src emacs-lisp
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(global-set-key (kbd "C-x 2") 'vsplit-other-window)
(global-set-key (kbd "C-x 3") 'hsplit-other-window)

#+end_src

**** Moving between windows

Moving between multiple windows is annoying when you just use 'C-x o'
(other-window). The following remaps C-c <arrow> to move between windows.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)

;; Repeat for keys where CTRL is kept pressed to prevent accidentally holding
;; CTRL and calling a different command function.
(global-set-key (kbd "C-c <C-left>")  'windmove-left)
(global-set-key (kbd "C-c <C-right>") 'windmove-right)
(global-set-key (kbd "C-c <C-up>")    'windmove-up)
(global-set-key (kbd "C-c <C-down>")  'windmove-down)
#+END_SRC

**** Re-sizing windows

Resizing windows is a pain with the mouse. Default bindings exist for increasing
the window's size horizontally (C-{ and C-}) but there are none for doing it
vertically. The following remapps the functions to do resizing (horizontally and
vertically) to 'C-x <arrow>' for consistency. This overwrites the two key
default key bindings: C-x <left> and C-x <right> which run the commands 
`previous-buffer` and `next-buffer` respectively.

Left and down are shrink, right and up are enlarge.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x <left>")  'shrink-window-horizontally)
(global-set-key (kbd "C-x <right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-x <down>")  'shrink-window)
(global-set-key (kbd "C-x <up>")    'enlarge-window)

;; Repeat for keys where CTRL is kept pressed to prevent accidentally holding
;; CTRL and calling a different command function.
(global-set-key (kbd "C-x <C-left>")  'shrink-window-horizontally)
(global-set-key (kbd "C-x <C-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-x <C-down>")  'shrink-window)
(global-set-key (kbd "C-x <C-up>")    'enlarge-window)
#+end_src

**** Winner mode

Winner mode allows you to undo/redo changes to window changes in Emacs.

Turning it on conflicts with C-c <left> and C-c <right>. Deal with conflict
and enable in future. Its benefits are too good to ignore!


#+BEGIN_SRC emacs-lisp

;; (global-set-key (kbd "")  'winner-mode)
;; (global-set-key (kbd "C-v <left>")  'winner-redo)
;; (global-set-key (kbd "")  'winner-undo)

#+END_SRC

** Frames
See http://www.emacswiki.org/emacs/FrameMove on how to intgrate framemove into
windmove.

** Scratch Buffer
Convenient package to create =*scratch*= buffers that are based on the
current buffer's major mode. This is more convienent than manually
creating a buffer to do some scratch work or reusing the initial
=*scratch*= buffer.

#+begin_src emacs-lisp
(use-package scratch
  :ensure t)
#+end_src

* Formatting and Display 
** Existing Bindings
| Keys    | Command        | Description                                   |
| M-q     | fill-paragraph | Wraps lines in the given paragraph around the |
|         |                | `column-fill` variable column.                |
| C-u M-q | fill-paragraph | Wraps text in paragraph but it is justified.  |
|         |                |                                               |
** Custom Bindings
*** Visual line mode

Visual line mode (VLM) is (sometimes) useful when dealing with lines which are
longer than the window can display in a line of its own. Usually when this
occurs an arrow is placed on the line to highlight that. Also the behaviour is
not very nice e.g. killing the line means killing the whole line (which could be
1000's lines below the actual visual line we want to kill).

By enabling VLM the behaviour is (sometimes) much more friendlier - we still
want lines which cannot be displayed on a single window line to have the arrow
in the margin but we want normal line operations to work on the visual line.
VLM does this. Other times it is just annoying as you may just want to kill the
whole line. 

#+BEGIN_SRC emacs-lisp
; (global-visual-line-mode)
; (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
; (diminish 'visual-line-mode)  ;; Remove 'vl Wrap' from mode line.
#+END_SRC

*** auto-fill-mode

auto-fill-mode is a minor mode which automatically wraps lines after the
`fill-column` variable is reached. We set it when a text mode is opened
so that it does not affect the shells/terminals.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c q") 'auto-fill-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(setq fill-column 80)  ; This is a buffer local change only (not global)
#+END_SRC

Setting the fill-column variable is a buffer local change and so we
need to set it by using a hook for the major mode we are interested in. 

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook (lambda () (set-fill-column 95)))
(add-hook 'org-mode-hook (lambda () (set-fill-column 95)))
#+END_SRC

* Themes

** Custom Theme Directory 

The variable "custom-theme-directory" is the default user directory for
storing custom theme files. The command `customize-create-theme' writes theme
files into this directory.  By default, Emacs searches for custom themes in this
directory first---see `custom-theme-load-path'.

#+BEGIN_SRC emacs-lisp

(setq custom-theme-directory "~/.emacs.d/themes/") ;; For enabling color themes.

#+END_SRC

* Sane Defaults
  

#+BEGIN_SRC emacs-lisp

;; Keep all backup and auto-save files in one directory
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

(setq-default indent-tabs-mode nil) ;; Do not use tabs - use spaces instead. 
(setq-default indicate-empty-lines t) ;; Indicate lines at bottom of file which are empty like vi.

(setq confirm-kill-emacs 'y-or-n-p) ;; Always confirm when exiting

(setq                                     ;; If two buffers with same name open, uniquify names.
 uniquify-buffer-name-style 'post-forward ;; Does not work for some reason.
 uniquify-separator         ":")

(show-paren-mode 1) ;; Highlight pairs of parens
(electric-pair-mode 1) ;; Automatically introduces closing parenthesis, brackets, braces, etc.
(delete-selection-mode t) ;; Delete the region when typing instead of only moving cursor.
(column-number-mode t) ;; Always show column number in modeline.

#+END_SRC

* Org Mode

** Org setup

#+BEGIN_SRC emacs-lisp

;; For org mode allow using shift to highlight text
;; (setq org-support-shift-select 'always) 

#+END_SRC

** Org images

The variable `org-startup-with-inline-images` can be set globally to
show inline images when loading a new Org file.

#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

Alternatively, you can set inline colours locally on a perfile basis by adding 
one of the following lines anywhere in the buffer:

`#+STARTUP: inlineimages`
`#+STARTUP: noinlineimages`

You can also toggle inline images with:
C-c C-x C-v     (org-toggle-inline-images)

** Org babel/source blocks

Pressing '<s TAB' in org mode automatically inserts a 'source code block'.

#+BEGIN_SRC emacs-lisp

;; Enable syntax highlighting for source code blocks within an org mode file.
(setq org-src-fontify-natively t)

#+END_SRC

* Text Mode

** Org Table Minor Mode
We want to create org tables easily in text files without having to
change the major mode to org mode. So if we are in a text file, open
org table minor mode so we can do this.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'orgtbl-mode)
#+END_SRC
* Searching and CUA Mode
** Searching
The library 'igrep' provides useful searching functionality such as 'fgrep-find'.

#+BEGIN_SRC emacs-lisp
;; 'M-x fgrep-find' useful for finding occurences of a string in a directory.
(require 'igrep) 

; Define keybinding so can be pressed whether CTRL is held down or not.
(global-set-key (kbd "C-x g") 'fgrep-find)
(global-set-key (kbd "C-x C-g") 'fgrep-find)
#+END_SRC

** CUA Mode

CUA mode rectangles are very useful.

#+BEGIN_SRC emacs-lisp
(setq cua-auto-tabify-rectangles nil) ;; Don't tabify after rectangle commands
(transient-mark-mode 1) ;; No region when it is not highlighted
#+END_SRC

* Eshell, Shell, Term, and Ansi-Term
** Shell autocompletion

See: http://stackoverflow.com/questions/163591/bash-autocompletion-in-emacs-shell-mode

In the emacs shell, it's actually emacs doing the auto-completion, not bash. If
the shell and emacs are out of sync (e.g. by using pushd, popd or some bash user
function that changes the shell's current directory), then auto-completion stops
working.

To fix this, just type 'dirs' into the shell and things get back in sync.
Alternatively there is the following keybinding:

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-\r" 'shell-resync-dirs) ;; Alt + return
#+END_SRC

*** Bash Completion Package

See: https://github.com/szermatt/emacs-bash-completion

Package allows for bash completition in normal shell.

#+begin_src emacs-lisp
(use-package bash-completion
  :ensure t
)  

;; Load package at start up.
(require 'bash-completion)
(bash-completion-setup)

; Turn package off: 
; (setq bash-completion-enabled nil)
#+end_src

** Colours
Resources for section:
- http://my-side-projects.blogspot.co.uk/2014/09/change-colour-of-emacs-shell-prompt-and.html
- http://stackoverflow.com/questions/25819034/colors-in-emacs-shell-prompt


We want to be able to have the shell show colours like a normal terminal.
To deal with colours in the shell we need to deal with comint-mode. ComintMode
is for making shell or repl like buffers in which to interact with an external
process.

#+BEGIN_SRC emacs-lisp
  
  ;; Add color to a shell running in emacs ‘M-x shell’
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  
  ;; Define the color vector. These are used for SGR (Select Graphic
  ;; Rendition) control sequences determining a color.
  (setq ansi-color-names-vector
    ["black" 
     "#FF0000"         ;; "red" 
     "green" 
     "yellow" 
     "PaleBlue" 
     "magenta" 
     "cyan" 
     "white"]
  )
#+END_SRC

Set specific colours for the terminal and shell.

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; Terminal Colours
 '(term-color-blue ((t (:background "#008B8B" :foreground "#008B8B"))))
 '(term-color-red ((t (:background "tomato" :foreground "tomato"))))
 ;; Shell Colours

)
#+END_SRC

*** Shell Prompt Colour

Run the command M-x list-faces-display and open the comint-highlight-prompt option.
line. Make sure that the comint-highlight-prompt face is NOT set to inherit
from anything. In my case it was set to inherit from the minibuffer
prompt - which sets things such as :weight, :foreground
and :background.  Removing the inheritance will prevent the colour
for the prompt from being overridden by the comint-highlight-prompt face.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'comint-highlight-prompt nil :inherit nil)

(custom-set-faces
  ;; Set the prompt to be green
  '(comint-highlight-prompt ((t (:foreground "green"))))
)

#+END_SRC



** Opening a shell/terminal

We create two functions: 

| Key Binding | Function Name         | Function Description                                |
|-------------+-----------------------+-----------------------------------------------------|
| C-M-1       | new-shell-same-window | Opens a new shell buffer, replacing the buffer in   |
|             | *custom function*     | the current window.                                 |
| C-M-!       | new-shell-new-window  | Opens a new shell buffer, replacing the buffer in a |
|             | *custom function*     | different window                                    |
| C-M-2       | ansi-term             | Opens an ansi terminal, replacing the buffer in the |
|             | *built in function*   | current window.                                     |


#+BEGIN_SRC emacs-lisp

(defun new-shell-same-window (name)
  "Opens a new shell buffer with the given name in asterisks (*name*) in the current directory and changes the prompt to 'name>'."
  (interactive "sShell in same window. Enter Name: ")
  (pop-to-buffer-same-window (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer)) 
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))

;; Binds C-M-1 to open a new shell in the current window.
(global-set-key (kbd "C-M-1") 'new-shell-same-window)

#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun new-shell-new-window (name)
  "Opens a new shell buffer with the given name in asterisks (*name*) in the current directory and changes the prompt to 'name>'."
  (interactive "sShell in new window. Enter Name: ")
  (pop-to-buffer (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer)) 
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))

;; Binds C-M-! to open a new shell in a new window.
(global-set-key (kbd "C-M-!") 'new-shell-new-window)

#+END_SRC

#+BEGIN_SRC emacs-lisp

;; C-M-2 opens new ANSI terminal in the current window. 
(global-set-key (kbd "C-M-2") 'ansi-term) 

#+END_SRC

** M-x shell

* Colours (General)
M-x commands to use to understand colours:

| Command                 | Description                                    |
| M-x list-colors-display | Lists the colour names available to use to set |
|                         | colours of different `attributes`.             |
| M-x list-faces-display  | Lists the `attributes` available to set the    |
|                         | colours to one of the `list-colors-display`.   |

* Flyspell/ISpell
** Default Dictionary
We want the default dictionary to be British english rather than American.

#+BEGIN_SRC emacs-lisp
(setq ispell-dictionary "british")
#+END_SRC
** Major Modes 
We want to turn flyspell mode on for the following major modes:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC


* Unicode and LaTeX
** Unicode

The function 'insert-char' allows you to insert unicode characters
based on their hex code.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c u") 'insert-char) ; u for unicode
#+END_SRC

** Latex
#+BEGIN_SRC emacs-lisp
;; Enable flyspell mode by default when editing LaTex.
(add-hook 'LaTeX-mode-hook 'turn-on-flyspell) 
#+END_SRC

* Languages
** Python

#+begin_src emacs-lisp
(use-package elpy
  :ensure t
  :config
  (elpy-enable)
  (define-key yas-minor-mode-map (kbd "C-c k") 'yas-expand) ;; Fixing a key binding bug in elpy
  (define-key global-map (kbd "C-c o") 'iedit-mode) ;; Fixing another key binding elpy bug in iedit mode

)



#+end_src


** Haskell

The following configuration assumes that the system has the following
installed on the host machine:
- Haskell platform (GHC, GHCi, Prelude, Cabal, etc.)
- Hlint

*** Haskell Mode

For starters we need to ensure we have Haskell mode installed.

#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
)
#+end_src

* Ido and Finding Files
** IDO
#+begin_src emacs-lisp
(use-package ido
  :init
  (progn
    (setq ido-enable-flex-matching t)
    (setq ido-everywhere t)
    (ido-mode t)
    ;; (use-package ido-ubiquitous
    ;;   :ensure t
    ;;   :init (ido-ubiquitous-mode))
    (use-package ido-vertical-mode
      :ensure t
      :init (ido-vertical-mode 1)
      (setq ido-vertical-define-keys 'C-n-and-C-p-only))))
#+end_src

When switching buffers in multiple frames, by default, if an existing
frame has the buffer open, ido will just move the cursor to that
buffer. We don't want that functionality so we change the default
buffer method to change in the selected window instead.

#+BEGIN_SRC emacs-lisp
(setq ido-default-buffer-method 'selected-window)
#+END_SRC

** Recent Files

#+BEGIN_SRC emacs-lisp
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 25)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+END_SRC
* Built In Packages
** Save Place
Save place allows you to reopen a buffer and have the point at the
position it was when the buffer was closed automatically.

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-file (concat user-emacs-directory ".saveplace.el"))
(setq-default save-place t)
#+END_SRC

** Electric Indent Mode
Electric indent mode automatically indents your next line when hitting return.
This can be useful for when in python you just want to continue the indentation
on the next line at the same level.

Although it works well most of the time, it has known issues with certain modes
e.g. ReST mode (rst-mode). See:
- http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation/
- http://docutils.sourceforge.net/docs/user/emacs.html
- http://stackoverflow.com/questions/21182550/how-to-turn-of-electric-indent-mode-for-specific-major-mode

After playing with it, I find it more annoying than useful. Use 'C-j' instead.

#+BEGIN_SRC emacs-lisp
; (electric-indent-mode t)
#+END_SRC
 
* Misc. ELPA, MELPA Packages
  
This section uses the 'use-package' package to configure the packages
downloaded from ELPA/MEPLA etc.

** Ace Jump Mode

A quick way to jump around text in buffers.

Demos:
- https://dl.dropboxusercontent.com/u/3254819/AceJumpModeDemo/AceJumpDemo.htm
- [[http://emacsrocks.com/e10.html][See Emacs Rocks Episode 10 for a screencast.]]

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-S-s" . ace-jump-mode))  ;; CTRL-SHIFT-s together
#+end_src

** Expand Region
Expands a region by semantic units e.g. for (setq alphabet-start "abc def") and the point being
somewhere within the "abc def" it would expand region to be in whole string, then to contents
of the sexp setq alphabet-start "abc def" and finally to the entire sexp.

#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
;  :diminish ace-jump-mode
  :bind ("C-=" . er/expand-region))
#+end_src


** Helm

Helm is incremental completion and selection narrowing framework for Emacs. It
will help steer you in the right direction when you're looking for stuff in
Emacs (like buffers, files, etc).

It makes buffers interactive and much nicer to deal with (among other things)!

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init (helm-mode)
  :bind (("M-y" . helm-show-kill-ring)
         ("C-x r b" . helm-bookmarks)
        ;; ("C-x C-b" . helm-buffers-list)
        )
)

;; From other config
  ;; :init (progn
  ;;         (require 'helm-config)
  ;;         (use-package helm-projectile
  ;;           :ensure t
  ;;           :commands helm-projectile
  ;;           :bind ("C-c p h" . helm-projectile))
  ;;         (use-package helm-ag :ensure t)
  ;;         (setq helm-locate-command "mdfind -interpret -name %s %s"
  ;;               helm-ff-newfile-prompt-p helm
  ;;               nil-M-x-fuzzy-match t)
  ;;         (helm-mode))
  ;; :bind (("C-c h" . helm-command-prefix)
  ;;        ("C-x b" . helm-mini)
  ;;        ("C-`" . helm-resume)
  ;;        ("M-x" . helm-M-x)
  ;;        ("C-x C-f" . helm-find-files))

#+END_SRC

*** Helm Swoop

Helm swoop is a nice replacement for M-x occur (M-s o).


#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :bind(("M-s o" . helm-swoop)     
        ("M-s M-o" . helm-swoop)
       )
)
#+END_SRC


** Magit

Interface for git projects. 

#+begin_src emacs-lisp
;; (use-package magit
;;   :ensure t
;;   :bind ("C-c g" . magit-status)
;;   :config
;;   (define-key magit-status-mode-map (kbd "q") 'magit-quit-session))
#+end_src


** Multiple Cursors

We'll also need to ~(require 'multiple-cusors)~ because of [[https://github.com/magnars/multiple-cursors.el/issues/105][an autoload issue]].

Multiple-cursors uses two lists of commands to know what to do: the run-once
list and the run-for-all list. It comes with a set of defaults, but it would be
beyond silly to try and include all the known Emacs commands.  

So that's why multiple-cursors occasionally asks what to do about a command. It
will then remember your choice by saving it in ~/.emacs.d/.mc-lists.el. You can
change the location with: (setq mc/list-file "/my/preferred/file") - do this
before requiring multiple cursors.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :init 
  ; (setq mc/list-file "/my/preferred/file")
  (require 'multiple-cursors)
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->"         . mc/mark-next-like-this)
         ("C-<"         . mc/mark-previous-like-this)
         ("C-c C-<"     . mc/mark-all-like-this)
         ("C-!"         . mc/mark-next-symbol-like-this)
         ("C-S-d"       . mc/mark-all-dwim)))
#+end_src


** Undo Tree

Undo tree allows you to visually view the undos which you have
done in your buffer. Useful keybindings once enabled globally are:

| Key      | Command                                 | Description                            |
| C-_  C-/ | undo-tree-undo                          | Undo changes.                          |
| M-_  C-? | undo-tree-redo                          | Redo changes.                          |
| C-x u    | undo-tree-visualize                     | Visualize the undo tree.               |
| C-x r u  | undo-tree-save-state-to-register        | Save current buffer state to register. |
| C-x r U  | undo-tree-restore-state-from-register   | Restore buffer state from register.    |
| <up>     | undo-tree-visualize-undo                | Undo changes.                          |
| <down>   | undo-tree-visualize-undo                | Undo changes.                          |
| <left>   | undo-tree-visualize-switch-branch-left  | Switch to previous undo-tree branch.   |
| <right>  | undo-tree-visualize-switch-branch-right | Switch to next undo-tree branch.       |
| t        | undo-tree-visualizer-toggle-timestamps  | Toggle display of time-stamps.         |
| q        | undo-tree-visualizer-quit               | Quit undo-tree-visualizer.             |


#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init 
   (global-undo-tree-mode)
   (setq undo-tree-visualizer-diff t)  
)
#+END_SRC
** YAML Mode

YAML is a human readable data serialization format. Sometimes
used for config files (Haskell Stack uses it a lot).

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
)
#+END_SRC
