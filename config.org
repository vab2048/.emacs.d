#+TITLE: Emacs Configuration File
#+AUTHOR: Vikram Bakshi
#+STARTUP: inlineimages

Key binding explanations:
- C-c <C-left> - Means CTRL must be pressed for both.

* TODO To look up


- https://gitlab.com/emacs-stuff/indent-tools
LOOK UP AND BIND WINNER MODE
LOOK UP AND ENABLE FLEX IDO MODE:
  - https://github.com/lewang/flx
  - 09 Buffers, Windows and IDO Mode

* Encoding

See:
- https://zhangda.wordpress.com/2016/02/15/configurations-for-beautifying-emacs-org-mode/

Basically, use UTF-8 unix encoding for all files with the given file extensions.
Make it unix line endings as well.

#+BEGIN_SRC emacs-lisp
;; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
(setq utf-translate-cjk-mode nil)

;; Use UTF-8 for all character encoding and 
(set-language-environment 'utf-8)
(set-locale-environment "en.UTF-8")

;; Set line endings to be unix
;; See https://stackoverflow.com/a/1674535/5108875
(prefer-coding-system 'utf-8-unix)
(set-buffer-file-coding-system 'utf-8-unix)
(setq-default buffer-file-coding-system 'utf-8-unix)
(setq-default default-buffer-file-coding-system 'utf-8-unix)
(set-selection-coding-system 'utf-8-unix)
(set-default-coding-systems 'utf-8-unix)
(set-terminal-coding-system 'utf-8-unix)
(set-keyboard-coding-system 'utf-8-unix)
#+END_SRC

In order to change the encoding on a buffer by buffer basis:

Call ~set-buffer-file-coding-system~, then give one of: {mac, dos, unix}. Then, save the file.

For more information on line endings, see: http://ergoemacs.org/emacs/emacs_line_ending_char.html

* Use-package notes
** Use-package

The use-package macro is used to configure packages. The syntax is simple:

(use-package <package-name>
   :<keyword> <arbitrary-elisp>
   :<keyword> <arbitrary-elisp>
   : ...
)

The simplest declaration is: (use-package foo)
Each subsection below describes a keyword and example usage.

*** :init

Executes code before a package is loaded.

Example:
(use-package foo
  :init
  (setq foo-variable t))

*** :config

Executes code after a package is loaded.

*** :bind

*Example:*
(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))

This does two things: first, it creates an autoload for the
ace-jump-mode command and defers loading of ace-jump-mode until you
actually use it. Second, it binds the key C-. to that command.

*Example 2*
(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
Same, but taking a list or a list of conses.

*** :mode
*** :ensure
*** :interpreter
*** :load-path

*Example 1*
(use-package ess-site
  :load-path "site-lisp/ess/lisp/"
  :commands R)

*Description*
This takes a symbol, a function, a string or a list of strings. If
the path is relative, it is expanded within user-emacs-directory:

*** :no-require
*** :if

(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))

*** :diminish

*Example 1*
(use-package abbrev
  :diminish abbrev-mode
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
*Description*
Removes the minor mode string from the modeline.


Use the :init keyword to execute code before a package is loaded. 
It accepts one or more forms, up until the next keyword:

-  In general, you should keep :init forms as simple and quick as
   possible, and put as much as you can get away with into the :config
   block. This way, deferred loading can help your Emacs to start as
   quickly as possible.

* Initialisation

Customisation options included here are placed for a faster/faster
looking initialisation.

#+BEGIN_SRC emacs-lisp

;; Turn off mouse interface early in startup to avoid momentary display
(when window-system
  ;; (menu-bar-mode -1)    ;; Menu bar - file, edit, etc.
  (tool-bar-mode -1)    ;; Tool bar - buttons under menu bar.
  (scroll-bar-mode -1)  ;; Scroll bar on side of buffers
  ;; (tooltip-mode -1)    ;; On: Help text as popup/Off: as text in minibuffer.
)

;; Don't show the tutorial startup page.
(setq inhibit-startup-message t) 

#+END_SRC

* Load Path

The following contains directories which are added to emac's load path.
That way if you want to configure a package which is not installed using MELPA
but exists in another folder - you can.

N.B. The (add-to-list 'load-path <path>) function DOES NOT 
recursively add subdirectories.

#+BEGIN_SRC emacs-lisp

;; "~/.emacs.d/lisp/" for custom downloaded lisp files.
(add-to-list 'load-path "~/.emacs.d/lisp/")  

#+END_SRC

* Personal Minor Mode
Create my own minor mode to contain my own functionality.
See 
- tutsplus - Venture into Emacs/02 Usage/12 Major and Minor Modes
- tutsplus - Venture into Emacs/02 Usage/13 Customizations


  
** Custom Minor Mode Functions
   
* Dired Mode

We can give the options that dired mode uses when it calls ls so that
they are: 

- l: Use the long listing format.
- a: Show all files including hidden ones.
- h: Print sizes in human readable format (K, M G etc.)
- F: Append an indicator onto relevant files/directories:
  - / is a directory
  - @ is a symlink
  - | is a named pipe (fifo)
  - = is a socket.
  - * for executable files
  - > is for a "door" -- a file type currently not implemented for Linux, but supported on Sun/Solaris.

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lahF")
#+END_SRC

* Minibuffer

Set the colour of the minibuffer prompt to green for better readability.
#+BEGIN_SRC emacs-lisp
 (custom-set-faces  
  '(minibuffer-prompt ((t (:foreground "green"))))  
 )  
#+END_SRC
** Powerline

#+begin_src emacs-lisp
(use-package powerline
  :ensure t
  :init (powerline-center-theme)
)
#+end_src

* Whitespace

** Show trailing whitespace

See:
- https://stackoverflow.com/a/11701899/5108875

The following defines a function "tf-toggle..." which when toggled on will highlight any
trailing whitespace in a buffer.

#+BEGIN_SRC emacs-lisp
(defun tf-toggle-show-trailing-whitespace ()
  "Toggle show-trailing-whitespace between t and nil"
  (interactive)
  (setq show-trailing-whitespace (not show-trailing-whitespace)))
#+END_SRC

* Buffers, Windows, Frames, and Scratch Buffer
** Buffers
*** ibuffer

iBuffer is an improved version of the default 'C-x C-b' (list-buffers
command). It comes with emacs by default so to use it we just need to define the
list-buffers command as an alias for it.

See: http://ergoemacs.org/emacs/emacs_buffer_management.html

#+begin_src emacs-lisp
;; make ibuffer the default buffer lister.
(defalias 'list-buffers 'ibuffer)
#+end_src

*** open as root

See
- http://emacsredux.com/blog/2013/04/21/edit-files-as-root/

If we open emacs as a standard user we cannot open files that we do not have permissions
for. The following allows you to open a file as root from within an existing emacs session.
We give it a key binding for ease of use. 

#+BEGIN_SRC sh
(defun sudo-edit (&optional arg)
  "Edit currently visited file as root.

With a prefix ARG prompt for a file to visit.
Will also prompt for a file to visit if current
buffer is not visiting a file."
  (interactive "P")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:"
                         (ido-read-file-name "Find file(as root): ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

    (global-set-key (kbd "<f7>") 'sudo-edit)
#+END_SRC



** Windows
*** Existing Bindings

| Keys  | Command              | Description                                            |
| C-x o | other-window         | Move point to other window.                            |
| C-x 0 | delete-window        | Deletes current window, reducing window count by 1.    |
| C-x 1 | delete-other-windows | Makes window point is on, sole window.                 |
| C-x 2 | split-window-below   | Splits current window horizontally into two.           |
| C-x 3 | split-window-right   | Splits current window vertically into two.             |
| C-x 4 |                      |                                                        |
| C-x 5 |                      | Used as a prefix for frame commands                    |
| C-x + | balance-windows      | Undos the affects of resizing windows so they balance. |
|       |                      |                                                        |


*** Custom Bindings
**** Splitting windows

Splitting windows does not move the cursor to the other window. The following
remaps the default keys to move to the other window when it is created.

#+begin_src emacs-lisp
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(global-set-key (kbd "C-x 2") 'vsplit-other-window)
(global-set-key (kbd "C-x 3") 'hsplit-other-window)

#+end_src

**** Moving between windows

Moving between multiple windows is annoying when you just use 'C-x o'
(other-window). The following remaps C-c <arrow> to move between windows.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)

;; Repeat for keys where CTRL is kept pressed to prevent accidentally holding
;; CTRL and calling a different command function.
(global-set-key (kbd "C-c <C-left>")  'windmove-left)
(global-set-key (kbd "C-c <C-right>") 'windmove-right)
(global-set-key (kbd "C-c <C-up>")    'windmove-up)
(global-set-key (kbd "C-c <C-down>")  'windmove-down)
#+END_SRC

**** Re-sizing windows

Resizing windows is a pain with the mouse. Default bindings exist for increasing
the window's size horizontally (C-{ and C-}) but there are none for doing it
vertically. The following remapps the functions to do resizing (horizontally and
vertically) to 'C-x <arrow>' for consistency. This overwrites the two key
default key bindings: C-x <left> and C-x <right> which run the commands 
`previous-buffer` and `next-buffer` respectively.

Left and down are shrink, right and up are enlarge.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x <left>")  'shrink-window-horizontally)
(global-set-key (kbd "C-x <right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-x <down>")  'shrink-window)
(global-set-key (kbd "C-x <up>")    'enlarge-window)

;; Repeat for keys where CTRL is kept pressed to prevent accidentally holding
;; CTRL and calling a different command function.
(global-set-key (kbd "C-x <C-left>")  'shrink-window-horizontally)
(global-set-key (kbd "C-x <C-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-x <C-down>")  'shrink-window)
(global-set-key (kbd "C-x <C-up>")    'enlarge-window)
#+end_src

**** Winner mode

Winner mode allows you to undo/redo changes to window changes in Emacs.

Turning it on conflicts with C-c <left> and C-c <right>. Deal with conflict
and enable in future. Its benefits are too good to ignore!


#+BEGIN_SRC emacs-lisp

;; (global-set-key (kbd "")  'winner-mode)
;; (global-set-key (kbd "C-v <left>")  'winner-redo)
;; (global-set-key (kbd "")  'winner-undo)

#+END_SRC

** Frames
See http://www.emacswiki.org/emacs/FrameMove on how to intgrate framemove into
windmove.

** Scratch Buffer
Convenient package to create =*scratch*= buffers that are based on the
current buffer's major mode. This is more convienent than manually
creating a buffer to do some scratch work or reusing the initial
=*scratch*= buffer.

#+begin_src emacs-lisp
(use-package scratch
  :ensure t)
#+end_src

* Formatting and Display 
** Existing Bindings
| Keys    | Command        | Description                                   |
| M-q     | fill-paragraph | Wraps lines in the given paragraph around the |
|         |                | `column-fill` variable column.                |
| C-u M-q | fill-paragraph | Wraps text in paragraph but it is justified.  |
|         |                |                                               |
** Custom Bindings
*** Visual line mode

Visual line mode (VLM) is (sometimes) useful when dealing with lines which are
longer than the window can display in a line of its own. Usually when this
occurs an arrow is placed on the line to highlight that. Also the behaviour is
not very nice e.g. killing the line means killing the whole line (which could be
1000's lines below the actual visual line we want to kill).

By enabling VLM the behaviour is (sometimes) much more friendlier - we still
want lines which cannot be displayed on a single window line to have the arrow
in the margin but we want normal line operations to work on the visual line.
VLM does this. Other times it is just annoying as you may just want to kill the
whole line. 

#+BEGIN_SRC emacs-lisp
  ; (global-visual-line-mode)

  ; Have arrows in margins to indicate logical line is wrapped
  ; even in visual line mode
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))

  ; (diminish 'visual-line-mode)  ;; Remove 'vl Wrap' from mode line.
#+END_SRC

*** auto-fill-mode

auto-fill-mode is a minor mode which automatically wraps lines after the
`fill-column` variable is reached. We set it when a text mode is opened
so that it does not affect the shells/terminals.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c q") 'auto-fill-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(setq fill-column 80)  ; This is a buffer local change only (not global)
#+END_SRC

Setting the fill-column variable is a buffer local change and so we
need to set it by using a hook for the major mode we are interested in. 

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook (lambda () (set-fill-column 95)))
(add-hook 'org-mode-hook (lambda () (set-fill-column 95)))
#+END_SRC

* Themes

** Custom Theme Directory 

The variable "custom-theme-directory" is the default user directory for
storing custom theme files. The command `customize-create-theme' writes theme
files into this directory.  By default, Emacs searches for custom themes in this
directory first---see `custom-theme-load-path'.

#+BEGIN_SRC emacs-lisp

(setq custom-theme-directory "~/.emacs.d/themes/") ;; For enabling color themes.

#+END_SRC

* Sane Defaults
  

#+BEGIN_SRC emacs-lisp

;; Keep all backup and auto-save files in one directory
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

(setq-default indent-tabs-mode nil) ;; Do not use tabs - use spaces instead. 
(setq-default indicate-empty-lines t) ;; Indicate lines at bottom of file which are empty like vi.

(setq confirm-kill-emacs 'y-or-n-p) ;; Always confirm when exiting

(setq                                     ;; If two buffers with same name open, uniquify names.
 uniquify-buffer-name-style 'post-forward ;; Does not work for some reason.
 uniquify-separator         ":")

(show-paren-mode 1) ;; Highlight pairs of parens
(electric-pair-mode 1) ;; Automatically introduces closing parenthesis, brackets, braces, etc.
(delete-selection-mode t) ;; Delete the region when typing instead of only moving cursor.
(column-number-mode t) ;; Always show column number in modeline.

#+END_SRC

* Org Mode

** Org setup

#+BEGIN_SRC emacs-lisp

;; For org mode allow using shift to highlight text
;; (setq org-support-shift-select 'always) 

#+END_SRC

** Org images

The variable `org-startup-with-inline-images` can be set globally to
show inline images when loading a new Org file.

#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

Alternatively, you can set inline colours locally on a perfile basis by adding 
one of the following lines anywhere in the buffer:

`#+STARTUP: inlineimages`
`#+STARTUP: noinlineimages`

You can also toggle inline images with:
C-c C-x C-v     (org-toggle-inline-images)

*** Setting custom width of images inline and for export

In order to be able to amend the image width displayed inline we need to do two things:
1. Set org-image-actual-width to nil
2. Give the image a width attribute

N.B. if no width attribute is given the image will be displayed inline in its entirety without
scaling i.e. however big it is.

#+BEGIN_SRC emacs-lisp
  ;; Doing step 1
  (setq org-image-actual-width nil)
#+END_SRC

Example of Step 2 when inserting an image:

#+CAPTION: 
#+NAME:   fig:business_domain_centric_approach_a
#+ATTR_ORG: :width 100
[[./Images/business_domain_centric_approach_a.png]]

** Org babel/source blocks

Pressing '<s TAB' in org mode automatically inserts a 'source code block'.

#+BEGIN_SRC emacs-lisp

;; Enable syntax highlighting for source code blocks within an org mode file.
(setq org-src-fontify-natively t)

;; Allow for the evaluation of the following source blocks
(org-babel-do-load-languages
 'org-babel-load-languages 
  '((emacs-lisp . t)
    (python . t)))

#+END_SRC

** Org misc settings

See:
- http://orgmode.org/manual/Special-symbols.html

By default org mode assumes:
- anything after a '_' should be subscript
  - e.g. ~some_name_of_variable~
- anything after a '^' should be superscript
  - e.g. ~2^x~
- this may or may not be what is desired

By setting org-use-sub-superscripts to "{}" then you can explicitly make org use
sub/superscript where you want:
- e.g:
  - ~some_name_of_variable~ - no subscript
  - ~a_{i}~                 - subscript
  - ~a^x~                   - no superscript
  - ~a^{x}~                 - superscript

#+BEGIN_SRC emacs-lisp

; Only make something after a '_' subscript if it is enclosed with {}
; Only make something after a '^' superscript if it is enclosed with {}
(setq org-use-sub-superscripts "{}")

; Set pretty-entities to true so superscripts and subscripts are displayed
; as WYSIWYM e.g. 2^{2} will appear as superscript and x_{i} will be subscript
(setq org-pretty-entities t)


#+END_SRC

* Custom Tweaks

** Open current directory of buffer in explorer

Taken from:
- https://emacs.stackexchange.com/a/7745

This creates an interactive function 'browse-file-directory' which will open up the directory
in your OS's file browser.

#+BEGIN_SRC emacs-lisp
(defun browse-file-directory ()
  "Open the current file's directory however the OS would."
  (interactive)
  (if default-directory
      (browse-url-of-file (expand-file-name default-directory))
    (error "No `default-directory' to open")))
#+END_SRC

* Text Mode

** Org Table Minor Mode
We want to create org tables easily in text files without having to
change the major mode to org mode. So if we are in a text file, open
org table minor mode so we can do this.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'orgtbl-mode)
#+END_SRC
* Searching and CUA Mode
** Searching
The library 'igrep' provides useful searching functionality such as 'fgrep-find'.

#+BEGIN_SRC emacs-lisp
;; 'M-x fgrep-find' useful for finding occurences of a string in a directory.
;; But it requires grep - so only use it if the OS is not windows

;; N.B. in emacs-lisp it is an 'if () then () else ()' construct
(if (eq system-type 'windows-nt)
  ;; if it is Windows do nothing
  (message "Detected emacs is running in Windows so not loading grep")
  ;; if not Windows assume we have the grep binary
  (progn
    (require 'igrep)
    ;; Define keybinding so can be pressed whether CTRL is held down or not.
    (global-set-key (kbd "C-x g") 'fgrep-find)
    (global-set-key (kbd "C-x C-g") 'fgrep-find))
)
#+END_SRC

** Ack

Ack is a perl program 


** CUA Mode

CUA mode rectangles are very useful.

#+BEGIN_SRC emacs-lisp
(setq cua-auto-tabify-rectangles nil) ;; Don't tabify after rectangle commands
(transient-mark-mode 1) ;; No region when it is not highlighted

;; Overwrite the Emacs rectangle command to use the CUA mode version instead
(global-set-key (kbd "C-x SPC") 'cua-rectangle-mark-mode)
#+END_SRC

* Eshell, Shell, Term, and Ansi-Term
** Shell autocompletion

See: http://stackoverflow.com/questions/163591/bash-autocompletion-in-emacs-shell-mode

In the emacs shell, it's actually emacs doing the auto-completion, not bash. If
the shell and emacs are out of sync (e.g. by using pushd, popd or some bash user
function that changes the shell's current directory), then auto-completion stops
working.

To fix this, just type 'dirs' into the shell and things get back in sync.
Alternatively there is the following keybinding:

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-\r" 'shell-resync-dirs) ;; Alt + return
#+END_SRC

*** Bash Completion Package

See: https://github.com/szermatt/emacs-bash-completion

Package allows for bash completition in normal shell.

#+begin_src emacs-lisp
(use-package bash-completion
  :ensure t
)  

;; Load package at start up.
(require 'bash-completion)
(bash-completion-setup)

; Turn package off: 
; (setq bash-completion-enabled nil)
#+end_src

** Colours
Resources for section:
- http://my-side-projects.blogspot.co.uk/2014/09/change-colour-of-emacs-shell-prompt-and.html
- http://stackoverflow.com/questions/25819034/colors-in-emacs-shell-prompt


We want to be able to have the shell show colours like a normal terminal.
To deal with colours in the shell we need to deal with comint-mode. ComintMode
is for making shell or repl like buffers in which to interact with an external
process.

#+BEGIN_SRC emacs-lisp
  
  ;; Add color to a shell running in emacs ‘M-x shell’
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  
  ;; Define the color vector. These are used for SGR (Select Graphic
  ;; Rendition) control sequences determining a color.
  (setq ansi-color-names-vector
    ["black" 
     "#FF0000"         ;; "red" 
     "green" 
     "yellow" 
     "PaleBlue" 
     "magenta" 
     "cyan" 
     "white"]
  )
#+END_SRC

Set specific colours for the terminal and shell.

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; Terminal Colours
 '(term-color-blue ((t (:background "#008B8B" :foreground "#008B8B"))))
 '(term-color-red ((t (:background "tomato" :foreground "tomato"))))
 ;; Shell Colours

)
#+END_SRC

*** Shell Prompt Colour

Run the command M-x list-faces-display and open the comint-highlight-prompt option.
line. Make sure that the comint-highlight-prompt face is NOT set to inherit
from anything. In my case it was set to inherit from the minibuffer
prompt - which sets things such as :weight, :foreground
and :background.  Removing the inheritance will prevent the colour
for the prompt from being overridden by the comint-highlight-prompt face.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'comint-highlight-prompt nil :inherit nil)

(custom-set-faces
  ;; Set the prompt to be green
  '(comint-highlight-prompt ((t (:foreground "green"))))
)

#+END_SRC



** Opening a shell/terminal

We create two functions: 

| Key Binding | Function Name         | Function Description                                |
|-------------+-----------------------+-----------------------------------------------------|
| C-M-1       | new-shell-same-window | Opens a new shell buffer, replacing the buffer in   |
|             | *custom function*     | the current window.                                 |
| C-M-!       | new-shell-new-window  | Opens a new shell buffer, replacing the buffer in a |
|             | *custom function*     | different window                                    |
| C-M-2       | ansi-term             | Opens an ansi terminal, replacing the buffer in the |
|             | *built in function*   | current window.                                     |


#+BEGIN_SRC emacs-lisp

(defun new-shell-same-window (name)
  "Opens a new shell buffer with the given name in asterisks (*name*) in the current directory and changes the prompt to 'name>'."
  (interactive "sShell in same window. Enter Name: ")
  (pop-to-buffer-same-window (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer)) 
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))

;; Binds C-M-1 to open a new shell in the current window.
(global-set-key (kbd "C-M-1") 'new-shell-same-window)

#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun new-shell-new-window (name)
  "Opens a new shell buffer with the given name in asterisks (*name*) in the current directory and changes the prompt to 'name>'."
  (interactive "sShell in new window. Enter Name: ")
  (pop-to-buffer (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer)) 
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))

;; Binds C-M-! to open a new shell in a new window.
(global-set-key (kbd "C-M-!") 'new-shell-new-window)

#+END_SRC

#+BEGIN_SRC emacs-lisp

;; C-M-2 opens new ANSI terminal in the current window. 
(global-set-key (kbd "C-M-2") 'ansi-term) 

#+END_SRC

** M-x shell

* Colours (General)
M-x commands to use to understand colours:

| Command                 | Description                                    |
| M-x list-colors-display | Lists the colour names available to use to set |
|                         | colours of different `attributes`.             |
| M-x list-faces-display  | Lists the `attributes` available to set the    |
|                         | colours to one of the `list-colors-display`.   |

* Grammar and spell checking

Flyspell enables on-the-fly spell checking in Emacs by the means of a minor mode. It is called
Flyspell. This facility is hardly intrusive. It requires no help. Flyspell highlights incorrect
words as soon as they are completed or as soon as the TextCursor hits a new word.

From Emacs 24.2, Emacs includes Flyspell. However, Flyspell needs a spell checking tool, which
is not included in Emacs. One of the older tools is called iSpell (there is still a lot of
documentation which refers to iSpell) but it has more or less been replaced by aspell now.


** Getting Aspell

*** Windows

1. Make sure you have cygwin installed
2. Make sure you have the apt-cyg utility available so you can install cygwin packages on the
   command line.
  - https://github.com/transcode-open/apt-cyg
3. Run ~apt-cyg install aspell~ to install aspell and ~apt-cyg install apell-en~ to install the
   english dictionaries required.

** Default Dictionary
We want the default dictionary to be British english rather than American.

#+BEGIN_SRC emacs-lisp
(setq ispell-dictionary "british")
#+END_SRC
** Flyspell major Modes 
We want to turn flyspell mode on for the following major modes:

#+BEGIN_SRC emacs-lisp
  
  (add-hook 'org-mode-hook 'flyspell-mode)

  ; For Scala just enable flyspell in the comments
  (add-hook 'scala-mode-hook
          (lambda ()
            (flyspell-prog-mode)))

  ; For Java just enable flyspell in the comments
  (add-hook 'java-mode-hook
          (lambda ()
            (flyspell-prog-mode)))

#+END_SRC

** Langtool

See:
- https://emacs.stackexchange.com/questions/2171/what-options-are-there-for-writing-better-non-programming-text-in-emacs#2176
- https://github.com/mhayashi1120/Emacs-langtool
  - It is also available on MELPA
- 

Langtool is a grammar checker that is commonly paired with Openoffice or Libreoffice. The tool
itself is a simple command line utility, so it is relatively easy to interface with other
programs; someone interfaced it with Emacs.
- Langtool requires Java



#+BEGIN_SRC emacs-lisp

(use-package langtool
  :ensure t
  :config
  ; (require 'langtool)
  ; (setq langtool-language-tool-jar "/path/to/languagetool-commandline.jar")
)

#+END_SRC

* Unicode and LaTeX
** Unicode

The function 'insert-char' allows you to insert unicode characters
based on their hex code.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c u") 'insert-char) ; u for unicode
#+END_SRC

** Latex
#+BEGIN_SRC emacs-lisp
;; Enable flyspell mode by default when editing LaTex.
(add-hook 'LaTeX-mode-hook 'turn-on-flyspell) 
#+END_SRC

* Languages
** Apache Web Server

We want ~apache-mode~ - a major mode for editing Apache configuration files.
This is useful for ~apache2.conf~ / ~httpd.conf~ / ~.htaccess~

#+begin_src emacs-lisp
(use-package apache-mode
  :ensure t
)
#+end_src



** Python

#+begin_src emacs-lisp
(use-package elpy
  :ensure t
  :config
  (elpy-enable)
  (define-key yas-minor-mode-map (kbd "C-c k") 'yas-expand) ;; Fixing a key binding bug in elpy
  (define-key global-map (kbd "C-c o") 'iedit-mode) ;; Fixing another key binding elpy bug in iedit mode

)



#+end_src

** Haskell

The following configuration assumes that the system has the following
installed on the host machine:
- Haskell platform (GHC, GHCi, Prelude, Cabal, etc.)
- Hlint

*** Haskell Mode

For starters we need to ensure we have Haskell mode installed.

#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
)
#+end_src

** Miranda

The following makes use of the Miranda Major Mode script originally found at:
http://www.iro.umontreal.ca/~lapalme/layout/miranda-mode.el

1. Make sure the miranda-mode.el file is in a directory that is in the load path.

This setting affects those files with a .m extension.

#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/lisp/miranda-mode.el")

#+END_SRC

** Scala

Taken from: 
- http://www.troikatech.com/blog/2014/11/26/ensime-and-emacs-as-a-scala-ide
- http://ensime.github.io/build_tools/sbt/

*Steps for setting up SCALA in emacs:*

1. Grab the package 'ensime'. This automatically installs:
 - scala-mode
 - sbt-mode

#+begin_src emacs-lisp
(use-package ensime
  :ensure t
)
#+end_src

2. Make sure the sbt binary is in the PATH.

3. Add the sbt-ensime plugin to the sbt (scala build tool) config:
  - File usually found: `~/.sbt/0.13/plugins/plugins.sbt'
  - Add the following source code to the relevant plugins.sbt file:
  #+BEGIN_EXAMPLE add_to_plugins_file
  if (sys.props("java.version").startsWith("1.6"))
    addSbtPlugin("org.ensime" % "sbt-ensime" % "1.0.0")
  else
    addSbtPlugin("org.ensime" % "sbt-ensime" % "1.11.2")
  #+END_EXAMPLE

4. Navigate to the base directory of a hello world scala application
 - Run 'sbt'
 - Run 'sbt compile'
 - Run 'sbt ensimeConfig'

5. Open a file in the scala project you want to run.
 - In the emacs line mode at the bottom it will say [ENSIME: Disconnected]

6. Create a connection to ensime
  - Run `M-x ensime`

7. The first time it will run will take a while - it will update the server.
  - It will appear `Scala : [<name of directory>]' once connected


#+BEGIN_SRC emacs-lisp
  ;; If you don't set this to nil you will get a message about
  ;; using snapshot version each time ENSIME connects to the server
  (setq ensime-startup-snapshot-notification nil)
#+END_SRC

*** Common errors

*Error: Could not retrieve sbt 0.13.9*
apt-get install ca-certificates-java
sudo update-ca-certificates -f 

*Shared Folders*
You cannot make symlinks between shared folders of a VM and the VM's other filesystem.
See http://stackoverflow.com/questions/28144833/operation-not-permitted-in-sbt-typesafe-activator-inside-vagrant-synced-folder


*You have a different version of scala for ENSIME (2.10.5) and root (2.11.7).*
[error] You have a different version of scala for ENSIME (2.10.5) and root (2.11.7).
[error] If this is not what you intended, use either
[error]   scalaVersion in ThisBuild := "2.11.7"
[error] in your build.sbt or add
[error]   ensimeScalaVersion in ThisBuild := "2.11.7"
[error] to a local ensime.sbt
[warn] No Java sources detected in /usr/lib/jvm/java-8-openjdk-amd64 (your ENSIME experience will not be as good as it could be.)

In the project's build.sbt file add the line which defines the ensimeScalaVersion:

#+BEGIN_EXAMPLE example_of_adding_ensimeScalaVersion
name := course.value + "-" + assignment.value

scalaVersion := "2.11.7"

ensimeScalaVersion in ThisBuild := "2.11.7" // For ensime (emacs)

#+END_EXAMPLE

*** Ensime key bindings

REPL
| C-c C-v z | Launch embedded Scala REPL which is project aware |

Errors
| C-c C-c e | List all errors and warnings in separate window.  |
| C-c C-v e | With cursor on error, display error in minibuffer |

** Idris

Configuration assuming you have Idris mode installed as well as the binaries (which are
available in your path)

#+begin_src emacs-lisp
(use-package idris-mode
  :ensure t
)
#+end_src


*** Features

The currently supported features of idris in emacs (via the compiler) )are:
- REPL
- Type checking
- Processing and displaying of errors
- Proof mode
- Case splitting
- etc.

| Binding        | Function name   | Description                                       |
|----------------+-----------------+---------------------------------------------------|
| M-x idris-repl | idris-repl      | Load an idris REPL                                |
| C-c C-l        | idris-load-file | Loads the current buffer/file into the idris-repl |
|                |                 |                                                   |



`M-x idris-repl` provides an interactive repl whose interaction is like a normal terminal repl
but specifically for emacs.

** INI
#+begin_src emacs-lisp
(use-package ini-mode
  :ensure t
)
#+end_src


** XML


Keybindings for nXML mode:

| Key     | Function            | Description                    |
|---------+---------------------+--------------------------------|
| C-c C-f | nxml-finish-element | Insert close tag automatically |

** PHP

#+begin_src emacs-lisp
(use-package php-mode
  :ensure t)
#+end_src


** Visual Basic

From https://github.com/emacsmirror/emacswiki.org/blob/master/visual-basic-mode.el

#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/lisp/visual-basic-mode.el")

  ; Set mode to autoload for the given file extensions
  (setq auto-mode-alist (append '(("\\.\\(frm\\|bas\\|cls\\|vba\\)$" .
                                  visual-basic-mode)) auto-mode-alist))


#+END_SRC

* TRAMP

** docker support

This adds package docker-tramp which offers TRAMP integration for docker containers.
E.G. you can type:

C-x C-f /docker:user@container:/path/to/file

where
  user           is the user that you want to use (optional)
  container      is the id or name of the container

#+begin_src emacs-lisp
    (use-package docker-tramp
      :ensure t
      ; By default it shows the id of the open containers when use type `/docker:`
      ; This is inconvenient - we would rather show the name so set the variable to true.
      :init (setq docker-tramp-use-names t))
#+end_src

** vagrant TRAMP

Causes issues when installed, so left out.

#+begin_src emacs-lisp
; (use-package vagrant-tramp
;   :ensure t)
#+end_src



* Ido and Finding Files
** IDO
#+begin_src emacs-lisp
(use-package ido
  :init
  (progn
    (setq ido-enable-flex-matching t)
    (setq ido-everywhere t)
    (ido-mode t)
    ;; (use-package ido-ubiquitous
    ;;   :ensure t
    ;;   :init (ido-ubiquitous-mode))
    (use-package ido-vertical-mode
      :ensure t
      :init (ido-vertical-mode 1)
      (setq ido-vertical-define-keys 'C-n-and-C-p-only))))
#+end_src

When switching buffers in multiple frames, by default, if an existing
frame has the buffer open, ido will just move the cursor to that
buffer. We don't want that functionality so we change the default
buffer method to change in the selected window instead.

#+BEGIN_SRC emacs-lisp
(setq ido-default-buffer-method 'selected-window)
#+END_SRC

** Recent Files

#+BEGIN_SRC emacs-lisp
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 25)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+END_SRC
* Built In Packages
** Save Place
Save place allows you to reopen a buffer and have the point at the
position it was when the buffer was closed automatically.

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-file (concat user-emacs-directory ".saveplace.el"))
(setq-default save-place t)
#+END_SRC

** Electric Indent Mode
Electric indent mode automatically indents your next line when hitting return.
This can be useful for when in python you just want to continue the indentation
on the next line at the same level.

Although it works well most of the time, it has known issues with certain modes
e.g. ReST mode (rst-mode). See:
- http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation/
- http://docutils.sourceforge.net/docs/user/emacs.html
- http://stackoverflow.com/questions/21182550/how-to-turn-of-electric-indent-mode-for-specific-major-mode

After playing with it, I find it more annoying than useful. Use 'C-j' instead.

#+BEGIN_SRC emacs-lisp
; (electric-indent-mode t)
#+END_SRC
 
* Misc. ELPA, MELPA Packages
  
This section uses the 'use-package' package to configure the packages
downloaded from ELPA/MEPLA etc.

** Ace Jump Mode

A quick way to jump around text in buffers.

Demos:
- https://dl.dropboxusercontent.com/u/3254819/AceJumpModeDemo/AceJumpDemo.htm
- [[http://emacsrocks.com/e10.html][See Emacs Rocks Episode 10 for a screencast.]]

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-M-j" . ace-jump-mode))  ;; ("C-S-s" . ace-jump-mode))  ;; CTRL-SHIFT-s together
        
#+end_src

** Expand Region
Expands a region by semantic units e.g. for (setq alphabet-start "abc def") and the point being
somewhere within the "abc def" it would expand region to be in whole string, then to contents
of the sexp setq alphabet-start "abc def" and finally to the entire sexp.

#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
;  :diminish ace-jump-mode
  :bind ("C-=" . er/expand-region))
#+end_src

** Helm

Helm is incremental completion and selection narrowing framework for Emacs. It
will help steer you in the right direction when you're looking for stuff in
Emacs (like buffers, files, etc).

It makes buffers interactive and much nicer to deal with (among other things)!

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init (helm-mode)
  :bind (("M-y" . helm-show-kill-ring)
         ("C-x r b" . helm-bookmarks)
         ("M-x" . helm-M-x)
        ;; ("C-x C-b" . helm-buffers-list)
        )
)

;; From other config
  ;; :init (progn
  ;;         (require 'helm-config)
  ;;         (use-package helm-projectile
  ;;           :ensure t
  ;;           :commands helm-projectile
  ;;           :bind ("C-c p h" . helm-projectile))
  ;;         (use-package helm-ag :ensure t)
  ;;         (setq helm-locate-command "mdfind -interpret -name %s %s"
  ;;               helm-ff-newfile-prompt-p helm
  ;;               nil-M-x-fuzzy-match t)
  ;;         (helm-mode))
  ;; :bind (("C-c h" . helm-command-prefix)
  ;;        ("C-x b" . helm-mini)
  ;;        ("C-`" . helm-resume)
  ;;        ("M-x" . helm-M-x)
  ;;        ("C-x C-f" . helm-find-files))

#+END_SRC

*** Helm Swoop

Helm swoop is a nice replacement for M-x occur (M-s o).


#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :bind(("M-s o" . helm-swoop)     
        ("M-s M-o" . helm-swoop)
       )
)
#+END_SRC

** Highlight Indentation

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :init 
   (highlight-indent-guides-mode)
   (setq highlight-indent-guides-method 'column)
)


#+END_SRC

** Magit

Interface for git projects. 

#+begin_src emacs-lisp
;; (use-package magit
;;   :ensure t
;;   :bind ("C-c g" . magit-status)
;;   :config
;;   (define-key magit-status-mode-map (kbd "q") 'magit-quit-session))
#+end_src

** Multiple Cursors

We'll also need to ~(require 'multiple-cusors)~ because of [[https://github.com/magnars/multiple-cursors.el/issues/105][an autoload issue]].

Multiple-cursors uses two lists of commands to know what to do: the run-once
list and the run-for-all list. It comes with a set of defaults, but it would be
beyond silly to try and include all the known Emacs commands.  

So that's why multiple-cursors occasionally asks what to do about a command. It
will then remember your choice by saving it in ~/.emacs.d/.mc-lists.el. You can
change the location with: (setq mc/list-file "/my/preferred/file") - do this
before requiring multiple cursors.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :init 
  ; (setq mc/list-file "/my/preferred/file")
  (require 'multiple-cursors)
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->"         . mc/mark-next-like-this)
         ("C-<"         . mc/mark-previous-like-this)
         ("C-c C-<"     . mc/mark-all-like-this)
         ("C-!"         . mc/mark-next-symbol-like-this)
         ("C-S-d"       . mc/mark-all-dwim)))
#+end_src

** Undo Tree

Undo tree allows you to visually view the undos which you have
done in your buffer. Useful keybindings once enabled globally are:

| Key      | Command                                 | Description                            |
| C-_  C-/ | undo-tree-undo                          | Undo changes.                          |
| M-_  C-? | undo-tree-redo                          | Redo changes.                          |
| C-x u    | undo-tree-visualize                     | Visualize the undo tree.               |
| C-x r u  | undo-tree-save-state-to-register        | Save current buffer state to register. |
| C-x r U  | undo-tree-restore-state-from-register   | Restore buffer state from register.    |
| <up>     | undo-tree-visualize-undo                | Undo changes.                          |
| <down>   | undo-tree-visualize-undo                | Undo changes.                          |
| <left>   | undo-tree-visualize-switch-branch-left  | Switch to previous undo-tree branch.   |
| <right>  | undo-tree-visualize-switch-branch-right | Switch to next undo-tree branch.       |
| t        | undo-tree-visualizer-toggle-timestamps  | Toggle display of time-stamps.         |
| q        | undo-tree-visualizer-quit               | Quit undo-tree-visualizer.             |


#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init 
   (global-undo-tree-mode)
   (setq undo-tree-visualizer-diff t)  
)
#+END_SRC
** Which Key

which-key is a minor mode for Emacs that displays the key bindings following your currently
entered incomplete command (a prefix) in a popup. For example, after enabling the minor mode if
you enter C-x and wait for the default of 1 second the minibuffer will expand with all of the
available key bindings that follow C-x (or as many as space allows given your settings). This
includes prefixes like C-x 8 which are shown in a different face.


#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
)

(require 'which-key)
(which-key-mode)
(which-key-setup-side-window-right-bottom)
#+END_SRC

Once a which-key buffer opens you can press C-h and then:
| n | next page     |
| p | previous page |
| u | undo last key stroke |


** YAML Mode

YAML is a human readable data serialization format. Sometimes
used for config files (Haskell Stack uses it a lot).

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
)
#+END_SRC

When in YAML we want to highlight indentations to make it clearer which level we are at:

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'highlight-indent-guides-mode)
#+END_SRC

