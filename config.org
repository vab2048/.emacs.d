
#+TITLE: Emacs Configuration File
#+AUTHOR: Vikram Bakshi
#+STARTUP: inlineimages

Key binding explanations:
- C-c <C-left> - Means CTRL must be pressed for both.

LOOK UP AND BIND WINNER MODE

* Use-package notes
** Use-package

The use-package macro is used to configure packages. The syntax is simple:

(use-package <package-name>
   :<keyword> <arbitrary-elisp>
   :<keyword> <arbitrary-elisp>
   : ...
)

The simplest declaration is: (use-package foo)
Each subsection below describes a keyword and example usage.

*** :init

Executes code before a package is loaded.

Example:
(use-package foo
  :init
  (setq foo-variable t))

*** :config

Executes code after a package is loaded.

*** :bind

*Example:*
(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))

This does two things: first, it creates an autoload for the
ace-jump-mode command and defers loading of ace-jump-mode until you
actually use it. Second, it binds the key C-. to that command.

*Example 2*
(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
Same, but taking a list or a list of conses.

*** :mode
*** :ensure
*** :interpreter
*** :load-path

*Example 1*
(use-package ess-site
  :load-path "site-lisp/ess/lisp/"
  :commands R)

*Description*
This takes a symbol, a function, a string or a list of strings. If
the path is relative, it is expanded within user-emacs-directory:

*** :no-require
*** :if

(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))

*** :diminish

*Example 1*
(use-package abbrev
  :diminish abbrev-mode
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
*Description*
Removes the minor mode string from the modeline.


Use the :init keyword to execute code before a package is loaded. 
It accepts one or more forms, up until the next keyword:

-  In general, you should keep :init forms as simple and quick as
   possible, and put as much as you can get away with into the :config
   block. This way, deferred loading can help your Emacs to start as
   quickly as possible.

* Initialisation

Customisation options included here are placed for a faster/faster
looking initialisation.

#+BEGIN_SRC emacs-lisp

;; Turn off mouse interface early in startup to avoid momentary display
(when window-system
  (menu-bar-mode -1)    ;; Menu bar - file, edit, etc.
  (tool-bar-mode -1)    ;; Tool bar - buttons under menu bar.
  (scroll-bar-mode -1)  ;; Scroll bar on side of buffers
  ;; (tooltip-mode -1)    ;; On: Help text as popup/Off: as text in minibuffer.
)

;; Don't show the tutorial startup page.
(setq inhibit-startup-message t) 

#+END_SRC

* Load Path

The following contains directories which are added to emac's load path.
That way if you want to configure a package which is not installed using MELPA
but exists in another folder - you can.

N.B. The (add-to-list 'load-path <path>) function DOES NOT 
recursively add subdirectories.

#+BEGIN_SRC emacs-lisp

;; "~/.emacs.d/lisp/" for custom downloaded lisp files.
(add-to-list 'load-path "~/.emacs.d/lisp/")  

#+END_SRC

* Dired Mode

We can give the options that dired mode uses when it calls ls so that
they are: 

- l: Use the long listing format.
- a: Show all files including hidden ones.
- h: Print sizes in human readable format (K, M G etc.)

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lah")
#+END_SRC

* Minibuffer

Set the colour of the minibuffer prompt to green for better readability.
#+BEGIN_SRC emacs-lisp
 (custom-set-faces  
  '(minibuffer-prompt ((t (:foreground "green"))))  
 )  
#+END_SRC
** Powerline

#+begin_src emacs-lisp
(use-package powerline
  :ensure t
  :init (powerline-center-theme)
)
#+end_src

* Buffers, Windows, Frames, and Scratch Buffer
** Buffers
*** ibuffer

iBuffer is an improved version of the default 'C-x C-b' (list-buffers
command). It comes with emacs by default so to use it we just need to define the
list-buffers command as an alias for it.

See: http://ergoemacs.org/emacs/emacs_buffer_management.html

#+begin_src emacs-lisp
;; make ibuffer the default buffer lister.
(defalias 'list-buffers 'ibuffer)
#+end_src

** Windows
*** Existing Bindings

| Keys  | Command              | Description                                            |
| C-x o | other-window         | Move point to other window.                            |
| C-x 0 | delete-window        | Deletes current window, reducing window count by 1.    |
| C-x 1 | delete-other-windows | Makes window point is on, sole window.                 |
| C-x 2 | split-window-below   | Splits current window horizontally into two.           |
| C-x 3 | split-window-right   | Splits current window vertically into two.             |
| C-x 4 |                      |                                                        |
| C-x 5 |                      | Used as a prefix for frame commands                    |
| C-x + | balance-windows      | Undos the affects of resizing windows so they balance. |
|       |                      |                                                        |


*** Custom Bindings
**** Splitting windows

Splitting windows does not move the cursor to the other window. The following
remaps the default keys to move to the other window when it is created.

#+begin_src emacs-lisp
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(global-set-key (kbd "C-x 2") 'vsplit-other-window)
(global-set-key (kbd "C-x 3") 'hsplit-other-window)

#+end_src

**** Moving between windows

Moving between multiple windows is annoying when you just use 'C-x o'
(other-window). The following remaps C-c <arrow> to move between windows.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)

;; Repeat for keys where CTRL is kept pressed to prevent accidentally holding
;; CTRL and calling a different command function.
(global-set-key (kbd "C-c <C-left>")  'windmove-left)
(global-set-key (kbd "C-c <C-right>") 'windmove-right)
(global-set-key (kbd "C-c <C-up>")    'windmove-up)
(global-set-key (kbd "C-c <C-down>")  'windmove-down)
#+END_SRC

**** Re-sizing windows

Resizing windows is a pain with the mouse. Default bindings exist for increasing
the window's size horizontally (C-{ and C-}) but there are none for doing it
vertically. The following remapps the functions to do resizing (horizontally and
vertically) to 'C-x <arrow>' for consistency. This overwrites the two key
default key bindings: C-x <left> and C-x <right> which run the commands 
`previous-buffer` and `next-buffer` respectively.

Left and down are shrink, right and up are enlarge.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x <left>")  'shrink-window-horizontally)
(global-set-key (kbd "C-x <right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-x <down>")  'shrink-window)
(global-set-key (kbd "C-x <up>")    'enlarge-window)

;; Repeat for keys where CTRL is kept pressed to prevent accidentally holding
;; CTRL and calling a different command function.
(global-set-key (kbd "C-x <C-left>")  'shrink-window-horizontally)
(global-set-key (kbd "C-x <C-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-x <C-down>")  'shrink-window)
(global-set-key (kbd "C-x <C-up>")    'enlarge-window)
#+end_src

**** Winner mode

Winner mode allows you to undo/redo changes to window changes in Emacs.

Turning it on conflicts with C-c <left> and C-c <right>. Deal with conflict
and enable in future. Its benefits are too good to ignore!


#+BEGIN_SRC emacs-lisp

;; (global-set-key (kbd "")  'winner-mode)
;; (global-set-key (kbd "C-v <left>")  'winner-redo)
;; (global-set-key (kbd "")  'winner-undo)

#+END_SRC

** Frames
See http://www.emacswiki.org/emacs/FrameMove on how to intgrate framemove into
windmove.

** Scratch Buffer
Convenient package to create =*scratch*= buffers that are based on the
current buffer's major mode. This is more convienent than manually
creating a buffer to do some scratch work or reusing the initial
=*scratch*= buffer.

#+begin_src emacs-lisp
(use-package scratch
  :ensure t)
#+end_src

* Formatting and Display 
** Existing Bindings
| Keys    | Command        | Description                                   |
| M-q     | fill-paragraph | Wraps lines in the given paragraph around the |
|         |                | `column-fill` variable column.                |
| C-u M-q | fill-paragraph | Wraps text in paragraph but it is justified.  |
|         |                |                                               |
** Custom Bindings

*** Visual line mode

Visual line mode (VLM) is useful when dealing with lines which are longer than
the window can display in a line of its own. Usually when this occurs an arrow
is placed on the line to highlight that. Also the behaviour is not very nice
e.g. killing the line means killing the whole line (which could be 1000's lines
below the actual visual line we want to kill).

By enabling VLM the behaviour is much more friendlier - we still want lines
which cannot be displayed on a single window line to have the arrow in the
margin but we want normal line operations to work on the visual line.
VLM does this.

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
(setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
(diminish 'visual-line-mode)  ;; Remove 'vl Wrap' from mode line.
#+END_SRC


*** auto-fill-mode

#+BEGIN_SRC emacs-lisp

;; auto-fill-mode is a minor mode which automatically wraps lines after the
;; `fill-column` variable is reached. We set it when a text mode is opened
;; so that it does not affect the shells/terminals.
(global-set-key (kbd "C-c q") 'auto-fill-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(setq fill-column 80)

#+END_SRC
* Themes

** Custom Theme Directory 

The variable "custom-theme-directory" is the default user directory for
storing custom theme files. The command `customize-create-theme' writes theme
files into this directory.  By default, Emacs searches for custom themes in this
directory first---see `custom-theme-load-path'.

#+BEGIN_SRC emacs-lisp

(setq custom-theme-directory "~/.emacs.d/themes/") ;; For enabling color themes.

#+END_SRC

* Sane Defaults
  

#+BEGIN_SRC emacs-lisp

;; Keep all backup and auto-save files in one directory
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

(setq-default indent-tabs-mode nil) ;; Do not use tabs - use spaces instead. 
(setq-default indicate-empty-lines t) ;; Indicate lines at bottom of file which are empty like vi.

(setq confirm-kill-emacs 'y-or-n-p) ;; Always confirm when exiting

(setq                                     ;; If two buffers with same name open, uniquify names.
 uniquify-buffer-name-style 'post-forward ;; Does not work for some reason.
 uniquify-separator         ":")

(show-paren-mode 1) ;; Highlight pairs of parens
(electric-pair-mode 1) ;; Automatically introduces closing parenthesis, brackets, braces, etc.
(delete-selection-mode t) ;; Delete the region when typing instead of only moving cursor.
(column-number-mode t) ;; Always show column number in modeline.

#+END_SRC

* Org Mode

** Org setup

#+BEGIN_SRC emacs-lisp

;; For org mode allow using shift to highlight text
;; (setq org-support-shift-select 'always) 

#+END_SRC

** Org images

The variable `org-startup-with-inline-images` can be set globally to
show inline images when loading a new Org file.

#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images t)
#+END_SRC

Alternatively, you can set inline colours locally on a perfile basis by adding 
one of the following lines anywhere in the buffer:

`#+STARTUP: inlineimages`
`#+STARTUP: noinlineimages`

You can also toggle inline images with:
C-c C-x C-v     (org-toggle-inline-images)

** Org babel/source blocks

Pressing '<s TAB' in org mode automatically inserts a 'source code block'.

#+BEGIN_SRC emacs-lisp

;; Enable syntax highlighting for source code blocks within an org mode file.
(setq org-src-fontify-natively t)

#+END_SRC
* Eshell, Shell, Term, and Ansi-Term
** Shell autocompletion

See: http://stackoverflow.com/questions/163591/bash-autocompletion-in-emacs-shell-mode

In the emacs shell, it's actually emacs doing the auto-completion, not bash. If
the shell and emacs are out of sync (e.g. by using pushd, popd or some bash user
function that changes the shell's current directory), then auto-completion stops
working.

To fix this, just type 'dirs' into the shell and things get back in sync.
Alternatively there is the following keybinding:

#+BEGIN_SRC emacs-lisp
(global-set-key "\M-\r" 'shell-resync-dirs) ;; Alt + return
#+END_SRC

*** Bash Completion Package

See: https://github.com/szermatt/emacs-bash-completion

Package allows for bash completition in normal shell.

#+begin_src emacs-lisp
(use-package bash-completion
  :ensure t
)  

;; Load package at start up.
(require 'bash-completion)
(bash-completion-setup)
#+end_src

** Colours
Resources for section:
- http://my-side-projects.blogspot.co.uk/2014/09/change-colour-of-emacs-shell-prompt-and.html
- http://stackoverflow.com/questions/25819034/colors-in-emacs-shell-prompt


We want to be able to have the shell show colours like a normal terminal.
To deal with colours in the shell we need to deal with comint-mode. ComintMode
is for making shell or repl like buffers in which to interact with an external
process.

#+BEGIN_SRC emacs-lisp
  
  ;; Add color to a shell running in emacs ‘M-x shell’
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  
  ;; Define the color vector. These are used for SGR (Select Graphic
  ;; Rendition) control sequences determining a color.
  (setq ansi-color-names-vector
    ["black" 
     "#FF0000"         ;; "red" 
     "green" 
     "yellow" 
     "PaleBlue" 
     "magenta" 
     "cyan" 
     "white"]
  )
#+END_SRC

Set specific colours for the terminal and shell.

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; Terminal Colours
 '(term-color-blue ((t (:background "#008B8B" :foreground "#008B8B"))))
 '(term-color-red ((t (:background "tomato" :foreground "tomato"))))
 ;; Shell Colours

)
#+END_SRC

*** Shell Prompt Colour

Run the command M-x list-faces-display and open the comint-highlight-prompt option.
line. Make sure that the comint-highlight-prompt face is NOT set to inherit
from anything. In my case it was set to inherit from the minibuffer
prompt - which sets things such as :weight, :foreground
and :background.  Removing the inheritance will prevent the colour
for the prompt from being overridden by the comint-highlight-prompt face.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'comint-highlight-prompt nil :inherit nil)

(custom-set-faces
  ;; Set the prompt to be green
  '(comint-highlight-prompt ((t (:foreground "green"))))
)

#+END_SRC



** Opening a shell/terminal

We create two functions: 

| Key Binding | Function Name         | Function Description                                |
|-------------+-----------------------+-----------------------------------------------------|
| C-M-1       | new-shell-same-window | Opens a new shell buffer, replacing the buffer in   |
|             | *custom function*     | the current window.                                 |
| C-M-!       | new-shell-new-window  | Opens a new shell buffer, replacing the buffer in a |
|             | *custom function*     | different window                                    |
| C-M-2       | ansi-term             | Opens an ansi terminal, replacing the buffer in the |
|             | *built in function*   | current window.                                     |


#+BEGIN_SRC emacs-lisp

(defun new-shell-same-window (name)
  "Opens a new shell buffer with the given name in asterisks (*name*) in the current directory and changes the prompt to 'name>'."
  (interactive "sShell in same window. Enter Name: ")
  (pop-to-buffer-same-window (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer)) 
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))

;; Binds C-M-1 to open a new shell in the current window.
(global-set-key (kbd "C-M-1") 'new-shell-same-window)

#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun new-shell-new-window (name)
  "Opens a new shell buffer with the given name in asterisks (*name*) in the current directory and changes the prompt to 'name>'."
  (interactive "sShell in new window. Enter Name: ")
  (pop-to-buffer (concat "*" name "*"))
  (unless (eq major-mode 'shell-mode)
    (shell (current-buffer))
    (sleep-for 0 200)
    (delete-region (point-min) (point-max))
    (comint-simple-send (get-buffer-process (current-buffer)) 
                        (concat "export PS1=\"\033[33m" name "\033[0m:\033[35m\\W\033[0m>\""))))

;; Binds C-M-! to open a new shell in a new window.
(global-set-key (kbd "C-M-!") 'new-shell-new-window)

#+END_SRC

#+BEGIN_SRC emacs-lisp

;; C-M-2 opens new ANSI terminal in the current window. 
(global-set-key (kbd "C-M-2") 'ansi-term) 

#+END_SRC

** M-x shell

* Colours (General)
M-x commands to use to understand colours:

| Command                 | Description                                    |
| M-x list-colors-display | Lists the colour names available to use to set |
|                         | colours of different `attributes`.             |
| M-x list-faces-display  | Lists the `attributes` available to set the    |
|                         | colours to one of the `list-colors-display`.   |


* LaTeX

#+BEGIN_SRC emacs-lisp
;; Enable flyspell mode by default when editing LaTex.
(add-hook 'LaTeX-mode-hook 'turn-on-flyspell) 
#+END_SRC

* Languages
** Python
** Haskell

The following configuration assumes that the system has the following
installed on the host machine:
- Haskell platform (GHC, GHCi, Prelude, Cabal, etc.)
- Hlint

*** Haskell Mode

For starters we need to ensure we have Haskell mode installed.

#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
)
#+end_src


* Misc. ELPA, MELPA Packages
  
This section uses the 'use-package' package to configure the packages
downloaded from ELPA/MEPLA etc.

** Ace Jump Mode

A quick way to jump around text in buffers.

Demos:
- https://dl.dropboxusercontent.com/u/3254819/AceJumpModeDemo/AceJumpDemo.htm
- [[http://emacsrocks.com/e10.html][See Emacs Rocks Episode 10 for a screencast.]]

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-S-s" . ace-jump-mode))  ;; CTRL-SHIFT-s together
#+end_src

** Helm

Helm is incremental completion and selection narrowing framework for Emacs. It
will help steer you in the right direction when you're looking for stuff in
Emacs (like buffers, files, etc).

It makes buffers interactive and much nicer to deal with (among other things)!

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :diminish helm-mode
  :init (helm-mode)
  :bind (("M-y" . helm-show-kill-ring)
         ("C-x r b" . helm-bookmarks)
        ;; ("C-x C-b" . helm-buffers-list)
        )
)

;; From other config
  ;; :init (progn
  ;;         (require 'helm-config)
  ;;         (use-package helm-projectile
  ;;           :ensure t
  ;;           :commands helm-projectile
  ;;           :bind ("C-c p h" . helm-projectile))
  ;;         (use-package helm-ag :ensure t)
  ;;         (setq helm-locate-command "mdfind -interpret -name %s %s"
  ;;               helm-ff-newfile-prompt-p helm
  ;;               nil-M-x-fuzzy-match t)
  ;;         (helm-mode))
  ;; :bind (("C-c h" . helm-command-prefix)
  ;;        ("C-x b" . helm-mini)
  ;;        ("C-`" . helm-resume)
  ;;        ("M-x" . helm-M-x)
  ;;        ("C-x C-f" . helm-find-files))

#+END_SRC

*** Helm Swoop

Helm swoop is a nice replacement for M-x occur (M-s o).


#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :bind(("M-s o" . helm-swoop)     
        ("M-s M-o" . helm-swoop)
       )
)
#+END_SRC



** Undo Tree

Undo tree allows you to visually view the undos which you have
done in your buffer. Useful keybindings once enabled globally are:

| Key      | Command                                 | Description                            |
| C-_  C-/ | undo-tree-undo                          | Undo changes.                          |
| M-_  C-? | undo-tree-redo                          | Redo changes.                          |
| C-x u    | undo-tree-visualize                     | Visualize the undo tree.               |
| C-x r u  | undo-tree-save-state-to-register        | Save current buffer state to register. |
| C-x r U  | undo-tree-restore-state-from-register   | Restore buffer state from register.    |
| <up>     | undo-tree-visualize-undo                | Undo changes.                          |
| <down>   | undo-tree-visualize-undo                | Undo changes.                          |
| <left>   | undo-tree-visualize-switch-branch-left  | Switch to previous undo-tree branch.   |
| <right>  | undo-tree-visualize-switch-branch-right | Switch to next undo-tree branch.       |
| t        | undo-tree-visualizer-toggle-timestamps  | Toggle display of time-stamps.         |
| q        | undo-tree-visualizer-quit               | Quit undo-tree-visualizer.             |


#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init 
   (global-undo-tree-mode)
   (setq undo-tree-visualizer-diff t)  
)
#+END_SRC
